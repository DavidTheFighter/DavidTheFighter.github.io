[{"content":"For my standard resume, click here to view it.\nPutting enough detail about my projects on a single page was difficult, so if you\u0026rsquo;d like more details then I\u0026rsquo;d encourage you to look through here! There\u0026rsquo;s four sections describing of each of my projects:\n Amateur Liquid Fueled Rocket Engine Breadboard Processor Fireworks Shell Taping Machine Custom Video Game Engine(s)  Amateur Liquid Fueled Rocket Engine, Personal Project This is a long-term side project of mine to build a (small) working liquid bipropellant rocket engine. My biggest goal isn\u0026rsquo;t necessarily a working engine, but to learn as much as possible about the discipline. Here\u0026rsquo;s the notable things from that project:\nIgniter The most successful milestone I\u0026rsquo;ve hit in this project was completing several test firings of a prototype torch igniter. I\u0026rsquo;ve written a blog post about it if you\u0026rsquo;d like more details. I originally wrote the controller software for it in C++ using the Arduino IDE, but I\u0026rsquo;ve since made an implementation in Rust of which I\u0026rsquo;m much more proud. Here\u0026rsquo;s a video of it working:\n  Embedded development As I detailed in the blog post about my igniter, I decided to get rid of the bird\u0026rsquo;s nest of wires and cobbled-together programming the first iteration igniter had. I was learning Rust at the time and decided a great way to dive head-first into both Rust and embedded development was to program the microcontroller using Rust. The i.MX RT 1062 MCU in the Teensy 4.1 I was using had mediocre Rust support, so I ended up creating my own ADC implementation and CANFD implementation from scratch. Both of these implementations directly manipulated the hardware registers. The custom circuit board I was designing the code for is shown as a render below:\nYou can download the KiCAD files here. And again if you want to see the Rust implementation for mission control and the engine controller, look here.\nCNC Mill The biggest (and most frustrating) part of the project was converting a Grizzly G0781 mini-mill into a CNC mill I could use. The poor thing was not designed or built with a CNC conversion in mind and led to quite a few stumbling blocks along the way. I upgraded it with precision ballscrews, stepper motors, a new belt drive system, and a mist coolant system. The whole thing is controlled by a Teensy 4.1 microcontroller running grbl-HAL. As of writing this, the machine is fully capable of running CNC programs but hasn\u0026rsquo;t been tested extensively. Here\u0026rsquo;s a short video of its first iteration doing a test run:\n  I\u0026rsquo;ve since done a lot more work on it, but I\u0026rsquo;m currently at RIT and don\u0026rsquo;t have access to it to take updated pictures. With the time I have at RIT I\u0026rsquo;m planning to write a blog post about this too, if anything so others don\u0026rsquo;t make the same mistakes I did.\nSkills Acquired Besides the visible products of this project, I learned a lot of skills along the way, such as:\n How to stick \u0026amp; TIG weld on steel and stainless steel Using Autodesk Fusion 360 \u0026amp; Inventor to design and analyze parts How to use 3D printers and slicer software How to operate manual milling machines and lathes Designing circuits in KiCAD and how to assemble, solder, and test them Basic circuit design, including a lot about MOSFETs The basics of embedded development, and how to use Rust on microcontrollers Basic metal fabrication techniques Basic principles about the operation of rocket engines Basics of CNC machining  (Partially) working Breadboard Processor, Personal Project This was an independent-study project I did during my senior year at high school. The goal was to design a processor on a breadboard using IC components that could run the original Super Mario Bros from the NES. I wasn\u0026rsquo;t able to fully complete that goal, but I learned a ton in the process about how processors work at the fundamental level. I started out making all of the common logic gates (AND, NOT, OR, XOR, NAND, flip flop, 2-bit adder and 4-bit chainable adder) out of N-channel transistors. I then designed and built a whole processor on a breadboard using 74LSxxx ICs as building blocks. Here\u0026rsquo;s a picture of it in it\u0026rsquo;s final version:\nI took a lot of inspiration from a gentleman named Ben Eater. He has a YouTube channel here where he has videos of him making a breadboard processor, a breadboard GPU that could output a VGA signal, and more amazing things. Ultimately I was able to execute some basic code on my processor, such as reading/writing to RAM and basic addition, but due to time constraints during the end of the school year and some bad clock timing configurations I wasn\u0026rsquo;t able to complete it.\nThose clock timing issues were the biggest problem I faced with. A lot of components were doing operations on the wrong part of the clock cycle (rising edge vs. falling edge), meaning components were both putting out a data signal and other components reading that data signal on the same clock edge. This results in unpredictable behaviour, and a lot of reconfiguration would be needed to make it deterministic.\nFireworks Shell Taping Machine, Personal Project This was another high school project of mine. One of my other hobbies was making fireworks. It was definitely one of the riskier projects I had going on, but I learned it from some great people that emphasized safe ways of practicing it to keep everybody involved free of harm. Regardless, one of my big issues was around a part of the firework construction process called \u0026ldquo;taping\u0026rdquo;. When constructing aerial shells, the black powder and stars need to be confined so they produce an aesthetic burst in the sky.\nThere are a couple ways of confining shells, but I chose the traditional method of using layers of paper tape. Unfortunately this is a time consuming process, so I searched for ways to automate it. I decided to replicate a design used by the Chinese fireworks manufacturers that utilize a 3-dimensional, rotating system to apply the tape evenly over the shell. This was my first real construction project so the quality isn\u0026rsquo;t amazing.\nI constructed the machine out of wood and used stepper motors to control each axis. A DC motor drove the large spinning wheel. I controlled all of the motors using an Arduino nano, whose (slightly messy) software can be found here. Here\u0026rsquo;s a video of the machine taping a 3\u0026quot; shell:\n  One of the big issues I encountered during the process was what patterns of tape would work best and be the most uniform. Trial error would be time-consuming and expensive, as well as hard to execute practically (measuring diameters woudld be far too inconsistent). I decided to write a bit of software that could simulate the taping process and calculate a heatmap of the layer count. I wrote it in C++, and while the code itself isn\u0026rsquo;t the neatest, I\u0026rsquo;m proud of the technical side of it. Here\u0026rsquo;s the repo for that. This is an example of the kind of heatmap it would produce:\nAnd of course, what would this be without a video of one of my taped shells in action? Here\u0026rsquo;s one of the best:\n  Custom Video Game Engine This wasn\u0026rsquo;t really one project, but more like 4 separate ones without a clear distinction between them. I started propgramming when I was 12 or 13 by making modifications for Minecraft, but I quickly knew I wanted to make my own games. I decided to program my own and started with a Java and OpenGL project to learn the basics of general and graphics programming. After quite a bit of tinkering, I decided I wanted to make the engine in C++. In my usual fashion, I decided diving in head first by making a whole engine in C++ was the best way to learn.\nI was about 14 when I started this C++ engine. I named it the \u0026ldquo;KindlingEngine\u0026rdquo;, and it evolved into a pretty capable (if messy) engine. It used the OpenGL 4.x API and featured a full tiled deferred renderer. It had a basic world system and effects such as: bloom, godrays, physically based rendering, a physically realistic sky (with a full day/night cycle), volumetric cloud rendering, screen space reflections, SMAA (antialiasing), screen space ambient occlusion, proper physics using Bullet Physics, and even character animations. Here\u0026rsquo;s a screenshot and a video of it running:\n  I worked on that sporadically for 2 or 3 years, but later the Vulkan API came out and I wanted to try it. I created a new C++ project I called the \u0026ldquo;StarlightEngine\u0026rdquo; and wrote a smaller engine using the new API. Here I experimented with making an abstraction layer that could support multiple APIs as backends (such as D3D12). Rather quickly I could see that my code wasn\u0026rsquo;t going to scale well, so of course I created another engine called the \u0026ldquo;KalosEngine\u0026rdquo; where I worked on a rendering backend that could do both Vulkan, D3D12, and even OpenGL (however I didn\u0026rsquo;t get far with OpenGL). I didn\u0026rsquo;t get far into this last engine before I moved on to other projects, but here\u0026rsquo;s a picture in-game of the StarlightEngine:\nThe code for the StarlightEngine can be found here and the code for the KalosEngine can be found here. While these two engines don\u0026rsquo;t have quite the breadth the KindlingEngine had, they\u0026rsquo;re more technically impressive and have a little bit better design. They were all created while I was in high school, so I was by no means a master at programming.\n","description":"My full resume","id":0,"section":"posts","tags":null,"title":"Resume - David Allen","uri":"/posts/resume/"},{"content":"Time I finally posted something :D\nI haven\u0026rsquo;t gotten as much done as I\u0026rsquo;d hoped, but I have managed to hack together design a prototype igniter to test out some systems and get a feel for everything. I figure I\u0026rsquo;d start with the igniter as it would be the simplest (and safest) system to prototype, and there\u0026rsquo;s actually flames involved!\nReasoning So why did I choose to do the igniter first? Well, to light the rocket engine I\u0026rsquo;m planning on building, I\u0026rsquo;ll need a reliable ignition source. I\u0026rsquo;m particularly worried about a hard start, or when a rocket engine has a delayed ignition. That delay allows fuel and oxidizer to collect in the combustion chamber of the engine, and when ignition happens a whole lot more propellant ignites at once than planned. At best it results in a combustion pressure spike. At worst, the engine blowing up. Not fun.\nMy only real options are either a torch igniter or what\u0026rsquo;s essentially an e-match on steroids. I decided against the e-match, as it felt too finicky for me. The e-matches used for black power model rocket engines are too small and would be blown out by the high pressure propellant. I\u0026rsquo;d have to beef it up with more flammable things, and feels like a finicky rabbit hole I don\u0026rsquo;t want to go down.\nThat leaves me with a torch igniter. It\u0026rsquo;s essentially a miniature rocket engine, but uses gaseous (most of the time) propellants and a spark plug. The smaller size and use of gaseous propellants means it can be ignited with a simple spark. The torch igniter will spew flames into the main combustion chamber right before propellants are allowed to flow in. Done right, it can be a very reliable and reusable ignition source.\nDesign Being my first actual engineering design, my methodology was a bit haphazardous. In the end, I decided to make it out of 304L stainless steel. Aluminum would be easier to machine, but I was afraid of the throat melting, and I wanted some experience with a tougher metal like stainless. I then used equations found in Rocket Propulsion Elements (by Sutton) to calculate the dimensions for the body. These dimensions included the throat radius, exit radius, estimated chamber dimensions, chamber pressure, mass flow rate, orifice diameter, and many many more parameters. The math to derive most of these equations is far beyond me, and even the derived equations are nothing to sneeze at. Regardless, I wasn\u0026rsquo;t too worried about hitting most of the dimensions too accurately, as I\u0026rsquo;m not looking for high performance from this thing. Only flames. Regardless, this design will be iterative, meaning I can always make changes later.\nTo actually get the gases inside the chamber and ignite, they have to be mixed. Luckily gases mix far more easily than liquids. I found a paper by some people at the University of Texas that detailed a swirl injector to mix the propellants. Essentially the oxygen is let in through the top, and fuel is injected tangentially a little ways down the body of the igniter. The fuel swirls around, and mixes the oxygen with it. Genius! For ignition, there was a little hole in the side further down the body that would accept a 1/4-32 RC spark plug. The gasses around injected into the chamber via orifices (orifi?). These exist to create a pressure drop from the gas supply into the chamber. If the chamber combustion pressure was higher than the supply pressure, you\u0026rsquo;d get wildly oscillating combustion or worse.\nTo control the flow of the gases, I used some cheap solenoid valves I got from Amazon. To prevent any potential blowblack into the gas bottles, I added some check valves too. At this point, the only real issue I was running into was calculating the mass flow of the gases (how many Kg/s of gas). The problem was each gas had to go through several restrictions, which can be treated as orifices, such as the solenoid valve, check valve, and injection orifice, and I needed to calculate how much gas would ultimately get into the igniter body. Because the propellants are gasses and therefore compressible, it\u0026rsquo;s reasonably hard to calculate mass flow through more than one orifice. Especially for an autodidact like me. (Epic foreshadowing). To get around this, I did a rough guesstimation calculation for the fuel orifices, and morphed the oxygen orifice into a needle valve so that I could adjust the flow rate on the fly.\nThe tangential fuel injection needs a little more thought. For this, I created a circumferential channel that went around the body. It was about 1/8\u0026quot; of an inch wide and about 1/8\u0026quot; deep. The injection orifice for the fuel would then be drilled tangentially into the body inside the channel. This channel will allow gas to be let in from one side of it and flow to each of the two holes. I\u0026rsquo;d then weld a manifold around this that I could attach a fitting to.\nConstruction To construct the thing, I took a length of 5/8\u0026quot; 304L stainless steel, cut it to length, and bored a hole through it using an extremely cheap (and I mean cheap, not inexpensive) hobby lathe. The process was a little tedious, but easier than I thought it would be (especially for stainless). I formed the nozzle using different sized drills. The oxygen side had a 1/8\u0026quot; NPT thread tapped into it for the needle valve and quick disonnect fitting going to the gas supply. For the spark plug, I drilled and tapped a threaded hole a ways down the body using my mill.\nNow for the fuel injection. I used my lathe to turn the circumferential channel (sorry no pictures). I then drilled the 2 0.7mm holes tangentially into the body inside the channel. Now, 0.7mm is TINY. Like, mechanical pencil lead tiny. I used jewlers drills to do this, made from what I believe to be tungesten carbide. I had to use my mini-mill to do this, due to it\u0026rsquo;s rigidity, concentricity, and high speed.\nI then TIG welded the simple square manifold onto the body. It had a 1/8\u0026quot; NPT port for a quick disconnect fitting. The final product ended up looking like this:\nNow onto how to control the whole bloody thing. I\u0026rsquo;m a software engineer by major, and I\u0026rsquo;ve worked with microcontrollers before, so I wasn\u0026rsquo;t too worried. I took a Teensy 4.1 and hacked together some C++ code to control everything. I interfaced to it using ethernet and controlled it from my laptop. No I\u0026rsquo;m not showing the code, as it would hurt my pride a little too much. That, and I\u0026rsquo;ve already worked at a first-approximation written in Rust that I\u0026rsquo;m far happier showing to the world. I did have some pressure and temperature sensors too, but (like an idiot) didn\u0026rsquo;t log any data. The whole thing was written and uploaded using the Arduino IDE with the Teensyduino extension.\nTest Setup My test setup consisted of an old oil tank with 1/8\u0026quot; thick steel walls on a hill behind my house. I figured I could operate the dangerous stuff on one side, and keep my flimsy human body on the other side. To securely mount the igniter for testing, I welded together a quick clamp-style mount that I could attach to the side of the tank (please refrain from making too much fun of my welding skills):\nFearing the worst, I put my microcontroller, gas tanks, and anything else expensive inside the oil tank. All of the control/power signals and gas lines were fed through an air vent. It ended up looking pretty janky and cobbled together (which I\u0026rsquo;ll talk about later). Here\u0026rsquo;s the full test setup:\nTesting I was pretty nervous the first time I attempted an ignition. Everything between an explosion and utter silence ran through my head. Apparently fate chose it to be the latter. It turned out a wire was loose, so I reset to try again. This was the first regret I had about the cobbled together design. In my latest iteration, it\u0026rsquo;s all controlled from a nice custom circuit board.\nThe next attempt, I got silence. Or, near silence, actually. I could hear the gas hissing out and the spark plug cracking, but no ignition. After a couple more failed attempts, and tweaking of the needle valve, I had a \u0026ldquo;screw it!\u0026rdquo; moment and turned the needle valve almost down to zero. On my next attempt, I heard two loud cracks! Upon inspecting the video feed, it had actually ignited twice very quickly! Really more of a fast deflagration than a sustained burn. Remember that epic foreshadowing about the orifices? Turns out I had enough oxygen that my mixture ratio was so far off it wouldn\u0026rsquo;t even ignite. Bummer.\nI then tried turning the needle valve down so far I couldn\u0026rsquo;t even tell if it was completely closed or not. I attempted again, and I got sustained ignition! I tried a few more times and I indeed got stable combustion. I cannot confirm nor deny that I squeeled like a child getting a new puppy :) Here\u0026rsquo;s two of the successful firings:\n     As a sidenote: see that spark at the beginning of that 2nd firing? My guess is it was a bit of the sparkplug electrode burning. I inspected it afterwards and found quite a bit of damage on it. The combustion is probably still very oxygen rich and could very well have eroded and ignited a chunk of it :)\nPrototype v0.1 Postmortem I learned A LOT from this igniter. Everything from basic machining to the first-approximation calcalations used to make real rocket engines. There\u0026rsquo;s quite a few things I\u0026rsquo;d change for the next iteration. First, the crazy bird\u0026rsquo;s nest of wires has to go. I\u0026rsquo;ve already done some prototyping of a custom circuit board that can be mounted close to the igniter and significantly improve the cabling. It features MOSFETs to drive the solenoids and spark plug, amplifiers for thermocouple inputs, and pressure sensor inputs. Here\u0026rsquo;s a 3D render of it:\nI\u0026rsquo;ve since ordered it, played around with it, and already have a new list of improvements I\u0026rsquo;d like to make (like MOSFET drivers!).\nI\u0026rsquo;m also going to attempt to simplify the orifice configuration for next time. I\u0026rsquo;m moving the check valves right next to the bottles. The igniter fires for a short enough enough time that the feed lines should act as a buffer and allow me to ignore the check valves in my orifice calculations. With this, I\u0026rsquo;d only need to worry about the injection orifices and the solenoid valves. It should also enable a higher mass flow.\nI\u0026rsquo;ve also decided to make the design thinner so that it\u0026rsquo;ll be easier to integrate it with the injector of the full engine. The walls are pretty thick as it is, and even with the thinner walls, it should have more than enough strength and thermal mass to deal with the measly forces of the igniter (crosses fingers).\nI also learned the importance of data logging. I really wished I had high frequency pressure data, from both the feed lines and from the combustion chamber itself. The next iteration will have many more sensor inputs and actually log the data this time. The software itself will also be far more capable next time, as I\u0026rsquo;ll have lots of time at college away from my setup to work on it.\nAll in all this was a good experience and it taught me a lot. I\u0026rsquo;m sad I didn\u0026rsquo;t get more than this done in the time I had, but I was also working on skills like operating a mill, using a stick and TIG welder, converting that mill to CNC, and many other things. Until next time!\n","description":"A working GOx and propane torch igniter","id":1,"section":"posts","tags":["igniter"],"title":"Igniter Prototype","uri":"/posts/igniter/"},{"content":"For better or for worse, I\u0026rsquo;ve decided to start a blog. I like doing just about anything technical that doesn\u0026rsquo;t involve biology (I still have the battle scars from freshman biology), and this blog should give me a chance to spread my ramblings. It might end up being pretty random, but hey, normal is boring right?\nMy current main project is to create a liquid fueled rocket engine. Did I mention I\u0026rsquo;m nuts? I\u0026rsquo;ve created a working torch igniter prototype (that needs a lot of work), and am in the process of finishing up a CNC mini-mill. I\u0026rsquo;ve had my fair share of roadblocks along the way, but needless to say I\u0026rsquo;ve learned a ridiculous amount so far. I\u0026rsquo;m currently away from home and attending college at RIT, so the project is being \u0026ldquo;redirected\u0026rdquo; a bit so that I can still work on parts of it here.\nEven if I can\u0026rsquo;t finish the project, the entire process will (and has been) a great learning experience for me. Regardless of what I\u0026rsquo;m working on you\u0026rsquo;ll get to see my successes and many failures along the way and hopefully get some second-hand learning of what not to do. Feel free to comment and email, as long as it\u0026rsquo;s not purposefully stupid I\u0026rsquo;d love to get feedback. I hope you enjoy, cheers!\n","description":"For better or worse, I'm doing it :)","id":2,"section":"posts","tags":["intro"],"title":"Uh oh, I think I'm starting a blog","uri":"/posts/intro/"}]